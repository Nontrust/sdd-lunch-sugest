## Context

현재 추천 시스템(`lib/recommend/service.ts`)은 카테고리 필터링 후 완전 랜덤으로 식당/메뉴를 선택한다. 데이터는 `data/restaurants.json`에 JSON 파일로 저장되며, `lib/storage/index.ts`가 읽기/쓰기를 담당한다. 추천 기록이 없어 동일 식당이 연속 추천될 수 있다.

## Goals / Non-Goals

**Goals:**
- 추천 결과를 히스토리로 자동 저장하고 날짜별로 조회할 수 있다
- 최근 N일 내 추천된 식당을 제외하는 스마트 추천을 제공한다
- 기존 랜덤 추천 동작을 유지하면서 스마트 추천을 기본값으로 사용한다

**Non-Goals:**
- 사용자별 히스토리 분리 (인증 시스템 없음, 단일 사용자 가정)
- 히스토리 데이터 DB 마이그레이션 (JSON 파일 유지)
- 메뉴 단위 중복 방지 (식당 단위로만 중복 방지)

## Decisions

### 1. 히스토리 저장소: 별도 JSON 파일

`data/history.json`에 히스토리를 저장한다. restaurants.json과 분리하여 관심사를 분리한다.

```json
{
  "records": [
    {
      "id": "1707600000000",
      "restaurantId": "1707500000000",
      "restaurantName": "스시이담",
      "menuName": "사시미 정식",
      "category": "japanese",
      "recommendedAt": "2026-02-11T12:00:00.000Z"
    }
  ]
}
```

**대안**: restaurants.json에 히스토리 필드 추가 → 관심사 혼합, 파일 비대화 우려로 기각.

### 2. 히스토리 서비스: 기존 storage 패턴 확장

`lib/history/service.ts`를 만들고, 히스토리 전용 storage 함수(`readHistory`, `writeHistory`)를 `lib/storage/index.ts`에 추가한다. 기존 패턴을 따라 일관성을 유지한다.

### 3. 추천 흐름: 추천 페이지에서 자동 저장

추천 API(`GET /api/recommend`)에서 추천 결과를 반환할 때 히스토리에 자동 저장한다. 별도 `POST /api/history` 없이 추천 API에서 일괄 처리하여 클라이언트 호출을 줄인다.

**대안**: 클라이언트에서 추천 후 별도 POST 호출 → 네트워크 실패 시 기록 누락 가능, 불필요한 왕복으로 기각.

### 4. 스마트 추천 로직

`lib/recommend/service.ts`의 `pick` 함수를 확장한다:
1. 히스토리에서 최근 N일(기본 3일) 내 추천된 restaurantId 목록을 가져온다
2. 카테고리 필터링된 후보에서 해당 식당들을 제외한다
3. 제외 후 후보가 없으면 폴백으로 전체 후보에서 랜덤 추천한다

`smart` 쿼리 파라미터(기본 `true`)로 스마트 추천 on/off를 제어한다.

### 5. 히스토리 조회 UI

`/history` 페이지를 추가하고 네비게이션에 "기록" 링크를 넣는다. 최근 7일간의 기록을 날짜별로 그룹핑하여 보여준다.

### 6. 중복 방지 기간: 3일 기본값

상수로 관리하여 추후 변경이 쉽도록 한다. 식당 수가 적을 때 폴백이 자주 발생할 수 있으므로 3일이 적절한 기본값이다.

## Risks / Trade-offs

- **[히스토리 파일 비대화]** → 실사용 규모(하루 1~2건)에서는 문제없음. 장기적으로 오래된 기록 정리 기능 추가 가능.
- **[식당 삭제 시 히스토리 정합성]** → 히스토리는 이름을 스냅샷으로 저장하므로 식당 삭제 후에도 기록은 유지된다. restaurantId 참조가 끊어져도 조회에는 문제없음.
- **[동시 쓰기 경합]** → 단일 사용자 환경이므로 무시 가능. 기존 storage와 동일한 수준의 리스크.
- **[폴백 발생 빈도]** → 등록 식당이 3개 이하이고 매일 추천받으면 폴백이 자주 발생. UI에 "최근 방문 식당이지만 추천합니다" 안내 표시.
